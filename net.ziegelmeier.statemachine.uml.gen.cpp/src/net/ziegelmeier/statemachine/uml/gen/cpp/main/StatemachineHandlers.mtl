[comment encoding = UTF-8 /]
[module StatemachineHandlers('http://www.eclipse.org/uml2/5.0.0/UML')]

[import net::ziegelmeier::statemachine::uml::gen::cpp::main::StatemachineQueries/]

[template public generateHandlers(aStatemachine : StateMachine)]
[file (aStatemachine.name.concat('Handlers.hxx'), false, 'UTF-8')]
// Statemachine [aStatemachine.name/] handlers
// Include this file in .cxx or in .hxx below Owner declaration

#pragma once

[aStatemachine.region.generateRegion(aStatemachine)/]
[/file]
[/template]

[comment --------------------------------------------------- /]

[template private generateRegion(aRegion : Region, aStatemachine : StateMachine)]
[aRegion.eContents(Vertex).generateVertex(aStatemachine)/]
[/template]

[template private generateVertex(aState : Vertex, aStatemachine : StateMachine)]
[/template]

[template private generateVertex(aState : State, aStatemachine : StateMachine)]
// State [aState.name/]
[let aFunctionName : String = aStatemachine.name + aState.name + 'Handler']
[aStatemachine.getTransitionType()/] [aStatemachine.getOwnerType()/]::[aFunctionName/]([aStatemachine.getStatePtrType()/] /* state */, [aStatemachine.getEventType()/] event)
{
	switch(event)
	{
	[let allEvents : Set(Event) = aState.outgoing->collect(getEvent())->asSet()]
	[for (anEvent : Event | allEvents)]
	case EEvent::[anEvent.name/]:
	{
	[let allTransitions : Set(Transition) = aState.outgoing->select(t | t.getEvent().name = anEvent.name)]
	[for (aTrans : Transition | allTransitions)]
		[aTrans.generateTransition(aStatemachine)/]
	[/for]
	[/let]
	}
	[/for]
	[/let]
	default:
		return [aStatemachine.name/]::UnhandledEvent();
	}
}
[/let]

[aState.eContents(Region).generateRegion(aStatemachine)/]
[/template]

[template private generateTransition(aTransition : Transition, aStatemachine : StateMachine)]
[aTransition.generateTransitionRecursive(aTransition, aStatemachine, Sequence(Constraint){})/]
[/template]

[template private generateTransitionRecursive(aTransition : Transition, aStartTransition : Transition, aStatemachine : StateMachine, guards : Sequence(Constraint))]
[if (aTransition.target.oclIsKindOf(State))]
[let allGuards : Sequence(Constraint) = guards->append(aTransition.guard)->select(g | not g.oclIsUndefined())]
[if (allGuards->isEmpty() or ((allGuards->size() = 1) and (allGuards->first().name = 'else')))]
return [aStatemachine.name/]::[aTransition.getTransitionVariable(aStartTransition)/];
[else]
if ([for (g : Constraint | allGuards) separator('&&')][g.name/][/for])
{
	return [aStatemachine.name/]::[aTransition.getTransitionVariable(aStartTransition)/];
}
[/if]
[/let]
[elseif (aTransition.target.oclIsTypeOf(Pseudostate) and aTransition.target.oclAsType(Pseudostate).kind = PseudostateKind::choice)]
[aTransition.target.oclAsType(Pseudostate).outgoing.generateTransitionRecursive(aStartTransition, aStatemachine, guards->append(aTransition.guard))/]
[/if]
[/template]
