[comment encoding = UTF-8 /]
[module StatemachineInstance('http://www.eclipse.org/uml2/5.0.0/UML')]

[import net::ziegelmeier::statemachine::uml::gen::cpp::main::StatemachineQueries/]

[template public generateInstance(aStatemachine : StateMachine)]
[file (aStatemachine.name.concat('Instance.hxx'), false, 'UTF-8')]
// Statemachine [aStatemachine.name/] instance

// Include this file in .cxx or in .hxx below implementation declaration
// *******
// Note: All referenced functions must be instance member functions that
// are either public OR [aStatemachine.name/] must be a friend class of [aStatemachine.getImplType()/] (add "friend class [aStatemachine.name/];" in your class)
// *******

// Override the following defines according to your needs if you are not using cpp_event_framework:

#ifndef [aStatemachine.name/]_GET_INSTANCE_EVENT_ID
#define [aStatemachine.name/]_GET_INSTANCE_EVENT_ID(event_instance) event_instance->Id()
#endif

#ifndef [aStatemachine.name/]_GET_STATIC_EVENT_ID
#define [aStatemachine.name/]_GET_STATIC_EVENT_ID(event_name) event_name::kId
#endif

[aStatemachine.region->asSequence()->first().generateInitialState(aStatemachine)/]

[aStatemachine.region->asSequence()->first().generateRegion(aStatemachine)/]

[aStatemachine.region.generateHandlers(aStatemachine)/]
[/file]
[/template]

[comment --------------------------------------------------- /]

[template private generateRegion(aRegion : Region, aStatemachine : StateMachine) post (trim())]
[aRegion.eContents(Vertex).generateVertex(aStatemachine)/]
[/template]

[template private generateInitialState(aRegion : Region, aStatemachine : StateMachine)]
// Initial state
const [aStatemachine.getStatePtrType()/] [aStatemachine.name/]::kInitialState = &[aStatemachine.name/]::k[aRegion.eContents(Pseudostate)->select(s | s.kind = PseudostateKind::initial)->first().outgoing->asSequence()->first().target.name/];
[/template]

[template private generateVertex(aState : Vertex, aStatemachine : StateMachine)]
[/template]

[template private generateVertex(aState : State, aStatemachine : StateMachine)]
// State [aState.name/]
const [aState.generateStateType(aStatemachine)/] [aStatemachine.name/]::[aState.getStateVariable()/]("[aState.name/]",
    &[aState.name/]Handler, // Handler
    [generateParent(aState, aStatemachine)/], // Parent
    [generateInitial(aState, aStatemachine)/], // Initial
    [generateEntryExit(aState.entry, aStatemachine)/], // Entry
    [generateEntryExit(aState.exit, aStatemachine)/]); // Exit
[aState.getExternalTransitions().generateExternalTransition(aStatemachine)/]
[aState.getInternalTransitions().generateInternalTransition(aStatemachine)/]

[aState.eContents(Region).generateRegion(aStatemachine)/]
[/template]

[template private generateEntryExit(aBehavior : Behavior, aStatemachine : StateMachine) post (trim())]
[if (aBehavior.oclIsUndefined())]
nullptr
[else]
&[aStatemachine.getImplType()/]::[aBehavior.name/]
[/if]
[/template]

[template private generateParent(aState : State, aStatemachine : StateMachine) post (trim())]
[if (aState.container.state.oclIsUndefined())]
nullptr
[else]
&k[aState.container.state.name/]
[/if]
[/template]

[template private generateInitial(aState : State, aStatemachine : StateMachine) post (trim())]
[if (aState.getSubRegion().getInitialPseudoState().getInitialState().oclIsUndefined())]
nullptr
[else]
&k[aState.getSubRegion().getInitialPseudoState().getInitialState().name/]
[/if]
[/template]

[template private generateStateType(aState : State, aStatemachine : StateMachine) post (trim())]
[if (not aState.getSubRegion().getInitialPseudoState().oclIsUndefined() and (aState.getSubRegion().getInitialPseudoState().kind = PseudostateKind::shallowHistory))]
[aStatemachine.name/]::HistoryState
[else]
[aStatemachine.name/]::State
[/if]
[/template]

[template private generateExternalTransition(aTransition : Transition, aStatemachine : StateMachine)]
[aTransition.generateTransitionRecursive(aTransition, aStatemachine, Sequence(Behavior){})/]
[/template]

[template private generateTransitionRecursive(aTransition : Transition, aStartTransition : Transition, aStatemachine : StateMachine, actions : Sequence(Behavior))]
[if (aTransition.target.oclIsKindOf(State))]
[if (actions->append(aTransition.effect)->filter(Behavior)->size() <> 0)]
const [aStatemachine.getTransitionType()/]::ActionType [aStatemachine.name/]::[aTransition.getTransitionVariable(aStartTransition)/]Actions['['/][']'/] = [generateTransitionActions(actions->append(aTransition.effect), aStatemachine)/];
const [aStatemachine.getTransitionType()/] [aStatemachine.name/]::[aTransition.getTransitionVariable(aStartTransition)/]([aTransition.target.getStateVariable()/], [aStatemachine.name/]::[aTransition.getTransitionVariable(aStartTransition)/]Actions);
[else]
const [aStatemachine.getTransitionType()/] [aStatemachine.name/]::[aTransition.getTransitionVariable(aStartTransition)/]([aTransition.target.getStateVariable()/]);
[/if]
[elseif (aTransition.target.oclIsTypeOf(Pseudostate) and aTransition.target.oclAsType(Pseudostate).kind = PseudostateKind::choice)]
[aTransition.target.oclAsType(Pseudostate).outgoing.generateTransitionRecursive(aStartTransition, aStatemachine, actions->append(aTransition.effect))/]
[/if]
[/template]

[template private generateTransitionActions(actions : Sequence(Behavior), aStatemachine : StateMachine)]
{[for (action : Behavior | actions->filter(Behavior)) separator (', ')]&[aStatemachine.getImplType()/]::[action.name/][/for]}
[/template]

[template private generateInternalTransition(aTransition : Transition, aStatemachine : StateMachine)]
[if (Sequence(Behavior){aTransition.effect}->filter(Behavior)->size() <> 0)]
const [aStatemachine.getTransitionType()/]::ActionType [aStatemachine.name/]::[aTransition.getTransitionVariable(aTransition)/]Actions['['/][']'/] = [generateTransitionActions(Sequence(Behavior){aTransition.effect}, aStatemachine)/];
const [aStatemachine.getTransitionType()/] [aStatemachine.name/]::[aTransition.getTransitionVariable(aTransition)/]([aStatemachine.name/]::kNone, [aStatemachine.name/]::[aTransition.getTransitionVariable(aTransition)/]Actions);
[else]
const [aStatemachine.getTransitionType()/] [aStatemachine.name/]::[aTransition.getTransitionVariable(aTransition)/]([aStatemachine.name/]::kNone);
[/if]

[/template]

[comment --------------------------------------------------- /]

[template private generateHandlers(aRegion : Region, aStatemachine : StateMachine)]
[aRegion.eContents(Vertex).generateHandlersVertex(aStatemachine)/]
[/template]

[template private generateHandlersVertex(aState : Vertex, aStatemachine : StateMachine)]
[/template]

[template private generateHandlersVertex(aState : State, aStatemachine : StateMachine)]
// State [aState.name/]
[let aFunctionName : String = aState.name + 'Handler']
[aStatemachine.getTransitionType()/] [aStatemachine.name/]::[aFunctionName/]([aStatemachine.getImplPtrType()/] impl, [aStatemachine.getEventType()/] event)
{
	(void)impl; // impl parameter is unused when there is no guard function being called in here

    switch([aStatemachine.name/]_GET_INSTANCE_EVENT_ID(event))
    {
    [let allEvents : Set(Event) = aState.outgoing->collect(getEvent())->asSet()]
    [for (anEvent : Event | allEvents)]
    case [aStatemachine.name/]_GET_STATIC_EVENT_ID([anEvent.name/]):
    [let allTransitions : Sequence(Transition) = aState.outgoing->select(t | t.getEvent().name = anEvent.name)->asSequence()->sortedBy(guard.oclIsUndefined() or (guard.name = 'else'))]
    [for (aTrans : Transition | allTransitions)]
        [aTrans.generateTransition(aTrans, aStatemachine)/]
    [/for]
    [/let]
    [/for]
    [/let]
    default:
        return [aStatemachine.name/]::UnhandledEvent();
    }
}
[/let]

[aState.eContents(Region).generateHandlers(aStatemachine)/]
[/template]

[template private generateTransition(aTransition : Transition, aStartTransition : Transition, aStatemachine : StateMachine)]
[if (aTransition.target.oclIsKindOf(State))]
[if (aTransition.guard.oclIsUndefined() or (aTransition.guard.name = 'else'))]
return [aStatemachine.name/]::[aTransition.getTransitionVariable(aStartTransition)/];
[else]
if (impl->[aTransition.guard.name/](event))
{
    return [aStatemachine.name/]::[aTransition.getTransitionVariable(aStartTransition)/];
}
[/if]
[elseif (aTransition.target.oclIsTypeOf(Pseudostate) and aTransition.target.oclAsType(Pseudostate).kind = PseudostateKind::choice)]
[if (not aTransition.guard.oclIsUndefined() and not (aTransition.guard.name = 'else'))]
if (impl->[aTransition.guard.name/](event))
{
    [generateTransitionRecursive(aStartTransition, aStatemachine)/]
}
[else]
[generateTransitionRecursive(aStartTransition, aStatemachine)/]
[/if]
[/if]
[/template]

[template private generateTransitionRecursive(aTransition : Transition, aStartTransition : Transition, aStatemachine : StateMachine) post (trim())]
[aTransition.target.oclAsType(Pseudostate).outgoing->asSequence()->sortedBy(guard.oclIsUndefined() or (guard.name = 'else')).generateTransition(aStartTransition, aStatemachine)/]
[/template]
