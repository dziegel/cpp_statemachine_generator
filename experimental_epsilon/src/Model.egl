[%
// Parse model and transform it to model-independent Tuples (TODO: Use Emfatic)

operation StateMachine getModel() : Tuple {
  var result = new Tuple();
  result.name = self.name;
  result.region = sm.regions.first.getModel(result);

  result.transformStatemachine();
  return result;
}

operation Region getModel(sm : Tuple) : Tuple {
  var result = new Tuple();

  var initial = self.subvertices.select(s | s.isKindOf(Pseudostate) and ((s.kind = PseudostateKind#initial) or (s.kind = PseudostateKind#shallowHistory))).first;
  result.initial = initial.outgoing.first.target.name;
  result.history = (initial.kind = PseudostateKind#shallowHistory);

  result.states = new List();
  for (state in self.subvertices.select(s | s.isKindOf(State))) {
    result.states.add(state.getModel(sm));
  }

  return result;
}

operation State getModel(sm : Tuple) : Tuple {
  var result = new Tuple();
  result.name = self.name;

  if (self.container.state != null) {
  	result.parent = self.container.state.name;
  }
  
  if (self.entry != null) {
  	result.entry = self.entry.name;
  }

  if (self.exit != null) {
  	result.exit = self.exit.name;
  }
  
  if (not self.regions.isEmpty()) {
    result.region = self.regions.first.getModel(sm);
  }

  result.transitions = new List();
  for (transition in self.outgoing.sortBy(t | (t.guard = null) or (t.guard.name = "else"))) {
    transition.getModel(sm, result, result.transitions);
  }
  
  return result;
}

operation Transition getModel(sm : Tuple, state : Tuple, transitions : List) : Tuple {
  var result = new Tuple();
  result.start = state.name;
  result.trigger = self.trigger.first.event.name;
  result.actions = new List();
  result.guards = new List();

  self.getTarget(sm, result, transitions);
  return result;
}

operation Transition getTarget(sm : Tuple, transition : Tuple, transitions : List) {
  if (self.effect != null) {
  	transition.actions.add(self.effect.name);
  }
  if ((self.guard != null) and (self.guard != "else")) {
  	transition.guards.add(self.guard.name);
  }

  if (self.target.isKindOf(State)) {
    transition.target = self.target.name;
    transitions.add(transition);
  }
  if ((self.target.isKindOf(Pseudostate)) and (self.target.kind = PseudostateKind#choice)) {
    for (choice_transition in self.target.outgoing.sortBy(t | (t.guard = null) or (t.guard.name = "else"))) {
      var t = new Tuple();
      t.start = transition.start;
      t.trigger = transition.trigger;
      t.actions = transition.actions.clone();
      t.guards = transition.guards.clone();
      choice_transition.getTarget(sm, t, transitions);
    }
  }
}

// Transformations

operation Tuple transformStatemachine() {
  self.transition_type = "Transition";
  self.transition_action_type = "Transition::Action";
  self.state_type = "State";
  self.event_type = "Event";
  self.impl_type = "Impl";
  self.impl_ptr_type = "ImplPtr";
  
  self.region.transformRegion(self);
}

operation Tuple transformRegion(statemachine : Tuple) {
  self.initial_variable_name = "k" + self.initial;

  self.states = self.states.sortBy(s | s.name);
  for (state in self.states) {
    state.transformState(statemachine);
  }
}

operation Tuple transformState(statemachine : Tuple) {
  self.variable_name = "k" + self.name;

  self.parent_variable_pointer = "nullptr";
  if (self.parent.isDefined()) {
    self.parent_variable_pointer = "&k" + self.parent;
  }
  
  self.entry_pointer = "nullptr";
  if (self.entry.isDefined()) {
    self.entry_pointer = "&" + self.entry;
  }

  self.exit_pointer = "nullptr";
  if (self.exit.isDefined()) {
    self.exit_pointer = "&" + self.exit;
  }

  self.transitions = self.transitions.sortBy(t | t.trigger + t.start + t.target);
  for (transition in self.transitions) {
    transition.transformTransition(statemachine);
  }

  self.initial_variable_pointer = "nullptr";
  if (self.region.isDefined()) {
    self.region.transformRegion(statemachine);
    self.initial_variable_pointer = "&" + self.region.initial_variable_name;
  }

  self.all_events = new List();  
  for (transition in self.transitions) {
    if (not self.all_events.includes(transition.trigger)) {
      self.all_events.add(transition.trigger);
    }
  }
  self.all_events = self.all_events.sortBy(e | e);

  self.all_event_transitions = new Map();
  for (event in self.all_events) {
    self.all_event_transitions.put(event, self.transitions.select(t | t.trigger = event));
  }
}

operation Tuple transformTransition(statemachine : Tuple) {
  self.target_variable_name = "k" + self.target;
  self.variable_name = "k" + self.start + "To" + self.target + "By"+ self.trigger;
  self.actions_variable_name = self.variable_name + "Actions";
  
  var actions = new List();
  for (action in self.actions) {
    actions.add("&" + statemachine.name + "::" + statemachine.impl_type + "::" + action);
  }
  self.actions_list = actions.concat(", ");
}
%]